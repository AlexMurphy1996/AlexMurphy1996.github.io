<!DOCTYPE html>
<html>
<head>
  <title>Agent CoPilot Widget</title>
</head>
<body>
  <h3>Watsonx Orchestrate Connector</h3>
  <div id="log" style="font-family: monospace; white-space: pre-wrap; max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px;"></div>

  <!-- Correct LP SDK -->
  <script type="text/javascript" charset="utf8" src="https://lpcdn.lpsnmedia.net/webagent/client-SDK.min.js"></script>

  <script>
    (async () => {
      if (!window.lpTag || !lpTag.agentSDK) {
        console.error("Agent SDK not available. Make sure this is running inside LivePerson Agent Workspace.");
        return;
      }

      // Initialize SDK
      const SDK = lpTag.agentSDK;
      SDK.init();

      const log = (msg) => {
        const logDiv = document.getElementById("log");
        logDiv.textContent += msg + "\n";
        logDiv.scrollTop = logDiv.scrollHeight;
      };

      log("Agent SDK initialized ✅");

      // --- Orchestrate Configuration ---
      const IAM_URL = "https://iam.cloud.ibm.com/identity/token";
      const API_KEY = "jMOWSXHPouV4qbyeQXRet4Nqos6hiTGe8jz4KVs-vmpQ";
      const ORCHESTRATE_BASE = "https://api.eu-gb.watson-orchestrate.cloud.ibm.com/instances/e10b6ef7-7a7d-49da-a8d3-6dee36cecfc8/v1";

      let accessToken = null;
      let tokenExpiry = 0;
      const sessionMap = {};

      async function getToken() {
        const now = Date.now() / 1000;
        if (accessToken && now < tokenExpiry - 60) return accessToken;

        log("Fetching new IAM token...");
        const res = await fetch(IAM_URL, {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: `grant_type=urn:ibm:params:oauth:grant-type:apikey&apikey=${API_KEY}`
        });

        if (!res.ok) throw new Error("Failed to fetch IAM token");
        const data = await res.json();
        accessToken = data.access_token;
        tokenExpiry = now + data.expires_in;
        log("→ Got IAM token");
        return accessToken;
      }

      async function getOrchestrateSession(conversationId) {
        if (sessionMap[conversationId]) return sessionMap[conversationId];

        const token = await getToken();
        log(`Creating Orchestrate session for conversation ${conversationId}...`);

        const res = await fetch(`${ORCHESTRATE_BASE}/sessions`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`,
          },
          body: JSON.stringify({ conversationId }),
        });

        if (!res.ok) throw new Error("Failed to create Orchestrate session");
        const data = await res.json();
        sessionMap[conversationId] = data.sessionId;
        log(`→ Session created: ${data.sessionId}`);
        return data.sessionId;
      }

      async function sendToOrchestrate(conversationId, text) {
        const sessionId = await getOrchestrateSession(conversationId);
        const token = await getToken();

        const res = await fetch(`${ORCHESTRATE_BASE}/sessions/${sessionId}/messages`, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${token}`,
          },
          body: JSON.stringify({ sender: "customer", text }),
        });

        if (!res.ok) throw new Error("Failed to send message");
        const data = await res.json();
        log(`→ Orchestrate response: ${JSON.stringify(data)}`);
      }

      // --- Listen for customer messages ---
      SDK.bind('chatTranscript.lines', function(data) {
        const lines = data.newValue || [];
        lines.forEach(line => {
          if (line.source === 'visitor' && line.text) {
            const conversationId = SDK.chatInfo?.rtSessionId || 'unknown';
            log(`[Customer] ${line.text}`);
            sendToOrchestrate(conversationId, line.text).catch(err => log("Error: " + err));
          }
        });
      });

      // --- Clean up sessions on conversation close ---
      SDK.bind('conversation.closed', function(data) {
        const conversationId = SDK.chatInfo?.rtSessionId || 'unknown';
        log(`Conversation ${conversationId} closed. Cleaning up Orchestrate session.`);
        delete sessionMap[conversationId];
      });

    })();
  </script>
</body>
</html>
